// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message_navit_map.proto

#ifndef PROTOBUF_INCLUDED_message_5fnavit_5fmap_2eproto
#define PROTOBUF_INCLUDED_message_5fnavit_5fmap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_message_5fnavit_5fmap_2eproto 

namespace protobuf_message_5fnavit_5fmap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_message_5fnavit_5fmap_2eproto
namespace navit {
namespace protocol {
namespace map_info {
class ItemProperty;
class ItemPropertyDefaultTypeInternal;
extern ItemPropertyDefaultTypeInternal _ItemProperty_default_instance_;
class MapArea;
class MapAreaDefaultTypeInternal;
extern MapAreaDefaultTypeInternal _MapArea_default_instance_;
class MapBasicInfo;
class MapBasicInfoDefaultTypeInternal;
extern MapBasicInfoDefaultTypeInternal _MapBasicInfo_default_instance_;
class MapConnectionInfo;
class MapConnectionInfoDefaultTypeInternal;
extern MapConnectionInfoDefaultTypeInternal _MapConnectionInfo_default_instance_;
class MapInfo;
class MapInfoDefaultTypeInternal;
extern MapInfoDefaultTypeInternal _MapInfo_default_instance_;
class MapLine;
class MapLineDefaultTypeInternal;
extern MapLineDefaultTypeInternal _MapLine_default_instance_;
class MapPoint;
class MapPointDefaultTypeInternal;
extern MapPointDefaultTypeInternal _MapPoint_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Property;
class PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class TotalMapInfo;
class TotalMapInfoDefaultTypeInternal;
extern TotalMapInfoDefaultTypeInternal _TotalMapInfo_default_instance_;
}  // namespace map_info
}  // namespace protocol
}  // namespace navit
namespace google {
namespace protobuf {
template<> ::navit::protocol::map_info::ItemProperty* Arena::CreateMaybeMessage<::navit::protocol::map_info::ItemProperty>(Arena*);
template<> ::navit::protocol::map_info::MapArea* Arena::CreateMaybeMessage<::navit::protocol::map_info::MapArea>(Arena*);
template<> ::navit::protocol::map_info::MapBasicInfo* Arena::CreateMaybeMessage<::navit::protocol::map_info::MapBasicInfo>(Arena*);
template<> ::navit::protocol::map_info::MapConnectionInfo* Arena::CreateMaybeMessage<::navit::protocol::map_info::MapConnectionInfo>(Arena*);
template<> ::navit::protocol::map_info::MapInfo* Arena::CreateMaybeMessage<::navit::protocol::map_info::MapInfo>(Arena*);
template<> ::navit::protocol::map_info::MapLine* Arena::CreateMaybeMessage<::navit::protocol::map_info::MapLine>(Arena*);
template<> ::navit::protocol::map_info::MapPoint* Arena::CreateMaybeMessage<::navit::protocol::map_info::MapPoint>(Arena*);
template<> ::navit::protocol::map_info::Point* Arena::CreateMaybeMessage<::navit::protocol::map_info::Point>(Arena*);
template<> ::navit::protocol::map_info::Property* Arena::CreateMaybeMessage<::navit::protocol::map_info::Property>(Arena*);
template<> ::navit::protocol::map_info::TotalMapInfo* Arena::CreateMaybeMessage<::navit::protocol::map_info::TotalMapInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace navit {
namespace protocol {
namespace map_info {

enum MapPoint_PointType {
  MapPoint_PointType_POINT_TYPE_DEFAULT = 0,
  MapPoint_PointType_POINT_TYPE_COMMON_STATION = 1,
  MapPoint_PointType_POINT_TYPE_CHARGE_PILE_STATION = 2,
  MapPoint_PointType_POINT_TYPE_NEARBY_CHARGE_PILE_STATION = 3,
  MapPoint_PointType_MapPoint_PointType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MapPoint_PointType_MapPoint_PointType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MapPoint_PointType_IsValid(int value);
const MapPoint_PointType MapPoint_PointType_PointType_MIN = MapPoint_PointType_POINT_TYPE_DEFAULT;
const MapPoint_PointType MapPoint_PointType_PointType_MAX = MapPoint_PointType_POINT_TYPE_NEARBY_CHARGE_PILE_STATION;
const int MapPoint_PointType_PointType_ARRAYSIZE = MapPoint_PointType_PointType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapPoint_PointType_descriptor();
inline const ::std::string& MapPoint_PointType_Name(MapPoint_PointType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapPoint_PointType_descriptor(), value);
}
inline bool MapPoint_PointType_Parse(
    const ::std::string& name, MapPoint_PointType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapPoint_PointType>(
    MapPoint_PointType_descriptor(), name, value);
}
enum MapLine_LineType {
  MapLine_LineType_LINE_TYPE_DEFAULT = 0,
  MapLine_LineType_LINE_TYPE_BEZIER = 1,
  MapLine_LineType_LINE_TYPE_DISCRETE = 2,
  MapLine_LineType_LINE_TYPE_ARC = 3,
  MapLine_LineType_LINE_TYPE_TEACHING = 4,
  MapLine_LineType_MapLine_LineType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MapLine_LineType_MapLine_LineType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MapLine_LineType_IsValid(int value);
const MapLine_LineType MapLine_LineType_LineType_MIN = MapLine_LineType_LINE_TYPE_DEFAULT;
const MapLine_LineType MapLine_LineType_LineType_MAX = MapLine_LineType_LINE_TYPE_TEACHING;
const int MapLine_LineType_LineType_ARRAYSIZE = MapLine_LineType_LineType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapLine_LineType_descriptor();
inline const ::std::string& MapLine_LineType_Name(MapLine_LineType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapLine_LineType_descriptor(), value);
}
inline bool MapLine_LineType_Parse(
    const ::std::string& name, MapLine_LineType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapLine_LineType>(
    MapLine_LineType_descriptor(), name, value);
}
enum MapArea_AreaType {
  MapArea_AreaType_AREA_TYPE_DEFAULT = 0,
  MapArea_AreaType_AREA_TYPE_FULL_COVERAGE = 1,
  MapArea_AreaType_AREA_TYPE_FORBIDDEN_AREA = 10,
  MapArea_AreaType_AREA_TYPE_FORBIDDEN_TURN_AREA = 11,
  MapArea_AreaType_AREA_TYPE_SLOW_DOWN_AREA = 12,
  MapArea_AreaType_AREA_TYPE_FORBIDDEN_BYPASS_OBS_AREA = 13,
  MapArea_AreaType_MapArea_AreaType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MapArea_AreaType_MapArea_AreaType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MapArea_AreaType_IsValid(int value);
const MapArea_AreaType MapArea_AreaType_AreaType_MIN = MapArea_AreaType_AREA_TYPE_DEFAULT;
const MapArea_AreaType MapArea_AreaType_AreaType_MAX = MapArea_AreaType_AREA_TYPE_FORBIDDEN_BYPASS_OBS_AREA;
const int MapArea_AreaType_AreaType_ARRAYSIZE = MapArea_AreaType_AreaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapArea_AreaType_descriptor();
inline const ::std::string& MapArea_AreaType_Name(MapArea_AreaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapArea_AreaType_descriptor(), value);
}
inline bool MapArea_AreaType_Parse(
    const ::std::string& name, MapArea_AreaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapArea_AreaType>(
    MapArea_AreaType_descriptor(), name, value);
}
enum ItemProperty_Propertiy {
  ItemProperty_Propertiy_DEFAULT = 0,
  ItemProperty_Propertiy_LINE_TOOL = 1,
  ItemProperty_Propertiy_POINT_TOOL = 2,
  ItemProperty_Propertiy_POLYGON_TOOL = 3,
  ItemProperty_Propertiy_ItemProperty_Propertiy_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ItemProperty_Propertiy_ItemProperty_Propertiy_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ItemProperty_Propertiy_IsValid(int value);
const ItemProperty_Propertiy ItemProperty_Propertiy_Propertiy_MIN = ItemProperty_Propertiy_DEFAULT;
const ItemProperty_Propertiy ItemProperty_Propertiy_Propertiy_MAX = ItemProperty_Propertiy_POLYGON_TOOL;
const int ItemProperty_Propertiy_Propertiy_ARRAYSIZE = ItemProperty_Propertiy_Propertiy_MAX + 1;

const ::google::protobuf::EnumDescriptor* ItemProperty_Propertiy_descriptor();
inline const ::std::string& ItemProperty_Propertiy_Name(ItemProperty_Propertiy value) {
  return ::google::protobuf::internal::NameOfEnum(
    ItemProperty_Propertiy_descriptor(), value);
}
inline bool ItemProperty_Propertiy_Parse(
    const ::std::string& name, ItemProperty_Propertiy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemProperty_Propertiy>(
    ItemProperty_Propertiy_descriptor(), name, value);
}
// ===================================================================

class Property : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.Property) */ {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(Property&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Property* other);
  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Property* New() const final {
    return CreateMaybeMessage<Property>(NULL);
  }

  Property* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string desc = 4;
  void clear_desc();
  static const int kDescFieldNumber = 4;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.Property)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(NULL);
  }

  Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // double rx = 4;
  void clear_rx();
  static const int kRxFieldNumber = 4;
  double rx() const;
  void set_rx(double value);

  // double ry = 5;
  void clear_ry();
  static const int kRyFieldNumber = 5;
  double ry() const;
  void set_ry(double value);

  // double rz = 6;
  void clear_rz();
  static const int kRzFieldNumber = 6;
  double rz() const;
  void set_rz(double value);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  double rx_;
  double ry_;
  double rz_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapBasicInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.MapBasicInfo) */ {
 public:
  MapBasicInfo();
  virtual ~MapBasicInfo();

  MapBasicInfo(const MapBasicInfo& from);

  inline MapBasicInfo& operator=(const MapBasicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapBasicInfo(MapBasicInfo&& from) noexcept
    : MapBasicInfo() {
    *this = ::std::move(from);
  }

  inline MapBasicInfo& operator=(MapBasicInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapBasicInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapBasicInfo* internal_default_instance() {
    return reinterpret_cast<const MapBasicInfo*>(
               &_MapBasicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MapBasicInfo* other);
  friend void swap(MapBasicInfo& a, MapBasicInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapBasicInfo* New() const final {
    return CreateMaybeMessage<MapBasicInfo>(NULL);
  }

  MapBasicInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapBasicInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapBasicInfo& from);
  void MergeFrom(const MapBasicInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapBasicInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string map_name = 2;
  void clear_map_name();
  static const int kMapNameFieldNumber = 2;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // string map_type = 3;
  void clear_map_type();
  static const int kMapTypeFieldNumber = 3;
  const ::std::string& map_type() const;
  void set_map_type(const ::std::string& value);
  #if LANG_CXX11
  void set_map_type(::std::string&& value);
  #endif
  void set_map_type(const char* value);
  void set_map_type(const char* value, size_t size);
  ::std::string* mutable_map_type();
  ::std::string* release_map_type();
  void set_allocated_map_type(::std::string* map_type);

  // string version = 7;
  void clear_version();
  static const int kVersionFieldNumber = 7;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .navit.protocol.map_info.Point min_pos = 4;
  bool has_min_pos() const;
  void clear_min_pos();
  static const int kMinPosFieldNumber = 4;
  private:
  const ::navit::protocol::map_info::Point& _internal_min_pos() const;
  public:
  const ::navit::protocol::map_info::Point& min_pos() const;
  ::navit::protocol::map_info::Point* release_min_pos();
  ::navit::protocol::map_info::Point* mutable_min_pos();
  void set_allocated_min_pos(::navit::protocol::map_info::Point* min_pos);

  // .navit.protocol.map_info.Point max_pos = 5;
  bool has_max_pos() const;
  void clear_max_pos();
  static const int kMaxPosFieldNumber = 5;
  private:
  const ::navit::protocol::map_info::Point& _internal_max_pos() const;
  public:
  const ::navit::protocol::map_info::Point& max_pos() const;
  ::navit::protocol::map_info::Point* release_max_pos();
  ::navit::protocol::map_info::Point* mutable_max_pos();
  void set_allocated_max_pos(::navit::protocol::map_info::Point* max_pos);

  // int64 map_id = 1;
  void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  ::google::protobuf::int64 map_id() const;
  void set_map_id(::google::protobuf::int64 value);

  // double resolution = 6;
  void clear_resolution();
  static const int kResolutionFieldNumber = 6;
  double resolution() const;
  void set_resolution(double value);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.MapBasicInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::google::protobuf::internal::ArenaStringPtr map_type_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::navit::protocol::map_info::Point* min_pos_;
  ::navit::protocol::map_info::Point* max_pos_;
  ::google::protobuf::int64 map_id_;
  double resolution_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.MapPoint) */ {
 public:
  MapPoint();
  virtual ~MapPoint();

  MapPoint(const MapPoint& from);

  inline MapPoint& operator=(const MapPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapPoint(MapPoint&& from) noexcept
    : MapPoint() {
    *this = ::std::move(from);
  }

  inline MapPoint& operator=(MapPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapPoint* internal_default_instance() {
    return reinterpret_cast<const MapPoint*>(
               &_MapPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MapPoint* other);
  friend void swap(MapPoint& a, MapPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapPoint* New() const final {
    return CreateMaybeMessage<MapPoint>(NULL);
  }

  MapPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapPoint& from);
  void MergeFrom(const MapPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MapPoint_PointType PointType;
  static const PointType POINT_TYPE_DEFAULT =
    MapPoint_PointType_POINT_TYPE_DEFAULT;
  static const PointType POINT_TYPE_COMMON_STATION =
    MapPoint_PointType_POINT_TYPE_COMMON_STATION;
  static const PointType POINT_TYPE_CHARGE_PILE_STATION =
    MapPoint_PointType_POINT_TYPE_CHARGE_PILE_STATION;
  static const PointType POINT_TYPE_NEARBY_CHARGE_PILE_STATION =
    MapPoint_PointType_POINT_TYPE_NEARBY_CHARGE_PILE_STATION;
  static inline bool PointType_IsValid(int value) {
    return MapPoint_PointType_IsValid(value);
  }
  static const PointType PointType_MIN =
    MapPoint_PointType_PointType_MIN;
  static const PointType PointType_MAX =
    MapPoint_PointType_PointType_MAX;
  static const int PointType_ARRAYSIZE =
    MapPoint_PointType_PointType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PointType_descriptor() {
    return MapPoint_PointType_descriptor();
  }
  static inline const ::std::string& PointType_Name(PointType value) {
    return MapPoint_PointType_Name(value);
  }
  static inline bool PointType_Parse(const ::std::string& name,
      PointType* value) {
    return MapPoint_PointType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .navit.protocol.map_info.Property property = 6;
  int property_size() const;
  void clear_property();
  static const int kPropertyFieldNumber = 6;
  ::navit::protocol::map_info::Property* mutable_property(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >*
      mutable_property();
  const ::navit::protocol::map_info::Property& property(int index) const;
  ::navit::protocol::map_info::Property* add_property();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >&
      property() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .navit.protocol.map_info.Point point = 4;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 4;
  private:
  const ::navit::protocol::map_info::Point& _internal_point() const;
  public:
  const ::navit::protocol::map_info::Point& point() const;
  ::navit::protocol::map_info::Point* release_point();
  ::navit::protocol::map_info::Point* mutable_point();
  void set_allocated_point(::navit::protocol::map_info::Point* point);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // .navit.protocol.map_info.MapPoint.PointType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::navit::protocol::map_info::MapPoint_PointType type() const;
  void set_type(::navit::protocol::map_info::MapPoint_PointType value);

  // bool ignore_dir = 5;
  void clear_ignore_dir();
  static const int kIgnoreDirFieldNumber = 5;
  bool ignore_dir() const;
  void set_ignore_dir(bool value);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.MapPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property > property_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::navit::protocol::map_info::Point* point_;
  ::google::protobuf::int64 id_;
  int type_;
  bool ignore_dir_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.MapLine) */ {
 public:
  MapLine();
  virtual ~MapLine();

  MapLine(const MapLine& from);

  inline MapLine& operator=(const MapLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapLine(MapLine&& from) noexcept
    : MapLine() {
    *this = ::std::move(from);
  }

  inline MapLine& operator=(MapLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapLine* internal_default_instance() {
    return reinterpret_cast<const MapLine*>(
               &_MapLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MapLine* other);
  friend void swap(MapLine& a, MapLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapLine* New() const final {
    return CreateMaybeMessage<MapLine>(NULL);
  }

  MapLine* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapLine>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapLine& from);
  void MergeFrom(const MapLine& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MapLine_LineType LineType;
  static const LineType LINE_TYPE_DEFAULT =
    MapLine_LineType_LINE_TYPE_DEFAULT;
  static const LineType LINE_TYPE_BEZIER =
    MapLine_LineType_LINE_TYPE_BEZIER;
  static const LineType LINE_TYPE_DISCRETE =
    MapLine_LineType_LINE_TYPE_DISCRETE;
  static const LineType LINE_TYPE_ARC =
    MapLine_LineType_LINE_TYPE_ARC;
  static const LineType LINE_TYPE_TEACHING =
    MapLine_LineType_LINE_TYPE_TEACHING;
  static inline bool LineType_IsValid(int value) {
    return MapLine_LineType_IsValid(value);
  }
  static const LineType LineType_MIN =
    MapLine_LineType_LineType_MIN;
  static const LineType LineType_MAX =
    MapLine_LineType_LineType_MAX;
  static const int LineType_ARRAYSIZE =
    MapLine_LineType_LineType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LineType_descriptor() {
    return MapLine_LineType_descriptor();
  }
  static inline const ::std::string& LineType_Name(LineType value) {
    return MapLine_LineType_Name(value);
  }
  static inline bool LineType_Parse(const ::std::string& name,
      LineType* value) {
    return MapLine_LineType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .navit.protocol.map_info.Point path = 6;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 6;
  ::navit::protocol::map_info::Point* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point >*
      mutable_path();
  const ::navit::protocol::map_info::Point& path(int index) const;
  ::navit::protocol::map_info::Point* add_path();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point >&
      path() const;

  // repeated .navit.protocol.map_info.Property property = 7;
  int property_size() const;
  void clear_property();
  static const int kPropertyFieldNumber = 7;
  ::navit::protocol::map_info::Property* mutable_property(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >*
      mutable_property();
  const ::navit::protocol::map_info::Property& property(int index) const;
  ::navit::protocol::map_info::Property* add_property();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >&
      property() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 start_point_id = 4;
  void clear_start_point_id();
  static const int kStartPointIdFieldNumber = 4;
  ::google::protobuf::int64 start_point_id() const;
  void set_start_point_id(::google::protobuf::int64 value);

  // int64 end_point_id = 5;
  void clear_end_point_id();
  static const int kEndPointIdFieldNumber = 5;
  ::google::protobuf::int64 end_point_id() const;
  void set_end_point_id(::google::protobuf::int64 value);

  // .navit.protocol.map_info.MapLine.LineType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::navit::protocol::map_info::MapLine_LineType type() const;
  void set_type(::navit::protocol::map_info::MapLine_LineType value);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.MapLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point > path_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property > property_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 start_point_id_;
  ::google::protobuf::int64 end_point_id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.MapArea) */ {
 public:
  MapArea();
  virtual ~MapArea();

  MapArea(const MapArea& from);

  inline MapArea& operator=(const MapArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapArea(MapArea&& from) noexcept
    : MapArea() {
    *this = ::std::move(from);
  }

  inline MapArea& operator=(MapArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapArea* internal_default_instance() {
    return reinterpret_cast<const MapArea*>(
               &_MapArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MapArea* other);
  friend void swap(MapArea& a, MapArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapArea* New() const final {
    return CreateMaybeMessage<MapArea>(NULL);
  }

  MapArea* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapArea>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapArea& from);
  void MergeFrom(const MapArea& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MapArea_AreaType AreaType;
  static const AreaType AREA_TYPE_DEFAULT =
    MapArea_AreaType_AREA_TYPE_DEFAULT;
  static const AreaType AREA_TYPE_FULL_COVERAGE =
    MapArea_AreaType_AREA_TYPE_FULL_COVERAGE;
  static const AreaType AREA_TYPE_FORBIDDEN_AREA =
    MapArea_AreaType_AREA_TYPE_FORBIDDEN_AREA;
  static const AreaType AREA_TYPE_FORBIDDEN_TURN_AREA =
    MapArea_AreaType_AREA_TYPE_FORBIDDEN_TURN_AREA;
  static const AreaType AREA_TYPE_SLOW_DOWN_AREA =
    MapArea_AreaType_AREA_TYPE_SLOW_DOWN_AREA;
  static const AreaType AREA_TYPE_FORBIDDEN_BYPASS_OBS_AREA =
    MapArea_AreaType_AREA_TYPE_FORBIDDEN_BYPASS_OBS_AREA;
  static inline bool AreaType_IsValid(int value) {
    return MapArea_AreaType_IsValid(value);
  }
  static const AreaType AreaType_MIN =
    MapArea_AreaType_AreaType_MIN;
  static const AreaType AreaType_MAX =
    MapArea_AreaType_AreaType_MAX;
  static const int AreaType_ARRAYSIZE =
    MapArea_AreaType_AreaType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AreaType_descriptor() {
    return MapArea_AreaType_descriptor();
  }
  static inline const ::std::string& AreaType_Name(AreaType value) {
    return MapArea_AreaType_Name(value);
  }
  static inline bool AreaType_Parse(const ::std::string& name,
      AreaType* value) {
    return MapArea_AreaType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .navit.protocol.map_info.Point path = 5;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 5;
  ::navit::protocol::map_info::Point* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point >*
      mutable_path();
  const ::navit::protocol::map_info::Point& path(int index) const;
  ::navit::protocol::map_info::Point* add_path();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point >&
      path() const;

  // repeated .navit.protocol.map_info.Property property = 6;
  int property_size() const;
  void clear_property();
  static const int kPropertyFieldNumber = 6;
  ::navit::protocol::map_info::Property* mutable_property(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >*
      mutable_property();
  const ::navit::protocol::map_info::Property& property(int index) const;
  ::navit::protocol::map_info::Property* add_property();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >&
      property() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 parent_id = 4;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 4;
  ::google::protobuf::int64 parent_id() const;
  void set_parent_id(::google::protobuf::int64 value);

  // .navit.protocol.map_info.MapArea.AreaType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::navit::protocol::map_info::MapArea_AreaType type() const;
  void set_type(::navit::protocol::map_info::MapArea_AreaType value);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.MapArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point > path_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property > property_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 parent_id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.MapInfo) */ {
 public:
  MapInfo();
  virtual ~MapInfo();

  MapInfo(const MapInfo& from);

  inline MapInfo& operator=(const MapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapInfo(MapInfo&& from) noexcept
    : MapInfo() {
    *this = ::std::move(from);
  }

  inline MapInfo& operator=(MapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapInfo* internal_default_instance() {
    return reinterpret_cast<const MapInfo*>(
               &_MapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MapInfo* other);
  friend void swap(MapInfo& a, MapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapInfo* New() const final {
    return CreateMaybeMessage<MapInfo>(NULL);
  }

  MapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapInfo& from);
  void MergeFrom(const MapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navit.protocol.map_info.MapPoint map_points = 11;
  int map_points_size() const;
  void clear_map_points();
  static const int kMapPointsFieldNumber = 11;
  ::navit::protocol::map_info::MapPoint* mutable_map_points(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapPoint >*
      mutable_map_points();
  const ::navit::protocol::map_info::MapPoint& map_points(int index) const;
  ::navit::protocol::map_info::MapPoint* add_map_points();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapPoint >&
      map_points() const;

  // repeated .navit.protocol.map_info.MapLine map_lines = 12;
  int map_lines_size() const;
  void clear_map_lines();
  static const int kMapLinesFieldNumber = 12;
  ::navit::protocol::map_info::MapLine* mutable_map_lines(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine >*
      mutable_map_lines();
  const ::navit::protocol::map_info::MapLine& map_lines(int index) const;
  ::navit::protocol::map_info::MapLine* add_map_lines();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine >&
      map_lines() const;

  // repeated .navit.protocol.map_info.MapArea map_areas = 13;
  int map_areas_size() const;
  void clear_map_areas();
  static const int kMapAreasFieldNumber = 13;
  ::navit::protocol::map_info::MapArea* mutable_map_areas(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapArea >*
      mutable_map_areas();
  const ::navit::protocol::map_info::MapArea& map_areas(int index) const;
  ::navit::protocol::map_info::MapArea* add_map_areas();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapArea >&
      map_areas() const;

  // repeated .navit.protocol.map_info.MapLine map_forbidden_lines = 21;
  int map_forbidden_lines_size() const;
  void clear_map_forbidden_lines();
  static const int kMapForbiddenLinesFieldNumber = 21;
  ::navit::protocol::map_info::MapLine* mutable_map_forbidden_lines(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine >*
      mutable_map_forbidden_lines();
  const ::navit::protocol::map_info::MapLine& map_forbidden_lines(int index) const;
  ::navit::protocol::map_info::MapLine* add_map_forbidden_lines();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine >&
      map_forbidden_lines() const;

  // .navit.protocol.map_info.MapBasicInfo map_basic_info = 1;
  bool has_map_basic_info() const;
  void clear_map_basic_info();
  static const int kMapBasicInfoFieldNumber = 1;
  private:
  const ::navit::protocol::map_info::MapBasicInfo& _internal_map_basic_info() const;
  public:
  const ::navit::protocol::map_info::MapBasicInfo& map_basic_info() const;
  ::navit::protocol::map_info::MapBasicInfo* release_map_basic_info();
  ::navit::protocol::map_info::MapBasicInfo* mutable_map_basic_info();
  void set_allocated_map_basic_info(::navit::protocol::map_info::MapBasicInfo* map_basic_info);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.MapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapPoint > map_points_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine > map_lines_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapArea > map_areas_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine > map_forbidden_lines_;
  ::navit::protocol::map_info::MapBasicInfo* map_basic_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapConnectionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.MapConnectionInfo) */ {
 public:
  MapConnectionInfo();
  virtual ~MapConnectionInfo();

  MapConnectionInfo(const MapConnectionInfo& from);

  inline MapConnectionInfo& operator=(const MapConnectionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapConnectionInfo(MapConnectionInfo&& from) noexcept
    : MapConnectionInfo() {
    *this = ::std::move(from);
  }

  inline MapConnectionInfo& operator=(MapConnectionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapConnectionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapConnectionInfo* internal_default_instance() {
    return reinterpret_cast<const MapConnectionInfo*>(
               &_MapConnectionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MapConnectionInfo* other);
  friend void swap(MapConnectionInfo& a, MapConnectionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapConnectionInfo* New() const final {
    return CreateMaybeMessage<MapConnectionInfo>(NULL);
  }

  MapConnectionInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapConnectionInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapConnectionInfo& from);
  void MergeFrom(const MapConnectionInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapConnectionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string from_map_id = 1;
  void clear_from_map_id();
  static const int kFromMapIdFieldNumber = 1;
  const ::std::string& from_map_id() const;
  void set_from_map_id(const ::std::string& value);
  #if LANG_CXX11
  void set_from_map_id(::std::string&& value);
  #endif
  void set_from_map_id(const char* value);
  void set_from_map_id(const char* value, size_t size);
  ::std::string* mutable_from_map_id();
  ::std::string* release_from_map_id();
  void set_allocated_from_map_id(::std::string* from_map_id);

  // string from_map_point_id = 2;
  void clear_from_map_point_id();
  static const int kFromMapPointIdFieldNumber = 2;
  const ::std::string& from_map_point_id() const;
  void set_from_map_point_id(const ::std::string& value);
  #if LANG_CXX11
  void set_from_map_point_id(::std::string&& value);
  #endif
  void set_from_map_point_id(const char* value);
  void set_from_map_point_id(const char* value, size_t size);
  ::std::string* mutable_from_map_point_id();
  ::std::string* release_from_map_point_id();
  void set_allocated_from_map_point_id(::std::string* from_map_point_id);

  // string to_map_id = 3;
  void clear_to_map_id();
  static const int kToMapIdFieldNumber = 3;
  const ::std::string& to_map_id() const;
  void set_to_map_id(const ::std::string& value);
  #if LANG_CXX11
  void set_to_map_id(::std::string&& value);
  #endif
  void set_to_map_id(const char* value);
  void set_to_map_id(const char* value, size_t size);
  ::std::string* mutable_to_map_id();
  ::std::string* release_to_map_id();
  void set_allocated_to_map_id(::std::string* to_map_id);

  // string to_map_point_id = 4;
  void clear_to_map_point_id();
  static const int kToMapPointIdFieldNumber = 4;
  const ::std::string& to_map_point_id() const;
  void set_to_map_point_id(const ::std::string& value);
  #if LANG_CXX11
  void set_to_map_point_id(::std::string&& value);
  #endif
  void set_to_map_point_id(const char* value);
  void set_to_map_point_id(const char* value, size_t size);
  ::std::string* mutable_to_map_point_id();
  ::std::string* release_to_map_point_id();
  void set_allocated_to_map_point_id(::std::string* to_map_point_id);

  // double cost = 5;
  void clear_cost();
  static const int kCostFieldNumber = 5;
  double cost() const;
  void set_cost(double value);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.MapConnectionInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_map_id_;
  ::google::protobuf::internal::ArenaStringPtr from_map_point_id_;
  ::google::protobuf::internal::ArenaStringPtr to_map_id_;
  ::google::protobuf::internal::ArenaStringPtr to_map_point_id_;
  double cost_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TotalMapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.TotalMapInfo) */ {
 public:
  TotalMapInfo();
  virtual ~TotalMapInfo();

  TotalMapInfo(const TotalMapInfo& from);

  inline TotalMapInfo& operator=(const TotalMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TotalMapInfo(TotalMapInfo&& from) noexcept
    : TotalMapInfo() {
    *this = ::std::move(from);
  }

  inline TotalMapInfo& operator=(TotalMapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TotalMapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TotalMapInfo* internal_default_instance() {
    return reinterpret_cast<const TotalMapInfo*>(
               &_TotalMapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TotalMapInfo* other);
  friend void swap(TotalMapInfo& a, TotalMapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TotalMapInfo* New() const final {
    return CreateMaybeMessage<TotalMapInfo>(NULL);
  }

  TotalMapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TotalMapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TotalMapInfo& from);
  void MergeFrom(const TotalMapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TotalMapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navit.protocol.map_info.MapInfo map_infos = 1;
  int map_infos_size() const;
  void clear_map_infos();
  static const int kMapInfosFieldNumber = 1;
  ::navit::protocol::map_info::MapInfo* mutable_map_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapInfo >*
      mutable_map_infos();
  const ::navit::protocol::map_info::MapInfo& map_infos(int index) const;
  ::navit::protocol::map_info::MapInfo* add_map_infos();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapInfo >&
      map_infos() const;

  // repeated .navit.protocol.map_info.MapConnectionInfo map_connection_infos = 2;
  int map_connection_infos_size() const;
  void clear_map_connection_infos();
  static const int kMapConnectionInfosFieldNumber = 2;
  ::navit::protocol::map_info::MapConnectionInfo* mutable_map_connection_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapConnectionInfo >*
      mutable_map_connection_infos();
  const ::navit::protocol::map_info::MapConnectionInfo& map_connection_infos(int index) const;
  ::navit::protocol::map_info::MapConnectionInfo* add_map_connection_infos();
  const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapConnectionInfo >&
      map_connection_infos() const;

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.TotalMapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapInfo > map_infos_;
  ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapConnectionInfo > map_connection_infos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ItemProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navit.protocol.map_info.ItemProperty) */ {
 public:
  ItemProperty();
  virtual ~ItemProperty();

  ItemProperty(const ItemProperty& from);

  inline ItemProperty& operator=(const ItemProperty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemProperty(ItemProperty&& from) noexcept
    : ItemProperty() {
    *this = ::std::move(from);
  }

  inline ItemProperty& operator=(ItemProperty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemProperty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemProperty* internal_default_instance() {
    return reinterpret_cast<const ItemProperty*>(
               &_ItemProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ItemProperty* other);
  friend void swap(ItemProperty& a, ItemProperty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemProperty* New() const final {
    return CreateMaybeMessage<ItemProperty>(NULL);
  }

  ItemProperty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemProperty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemProperty& from);
  void MergeFrom(const ItemProperty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ItemProperty_Propertiy Propertiy;
  static const Propertiy DEFAULT =
    ItemProperty_Propertiy_DEFAULT;
  static const Propertiy LINE_TOOL =
    ItemProperty_Propertiy_LINE_TOOL;
  static const Propertiy POINT_TOOL =
    ItemProperty_Propertiy_POINT_TOOL;
  static const Propertiy POLYGON_TOOL =
    ItemProperty_Propertiy_POLYGON_TOOL;
  static inline bool Propertiy_IsValid(int value) {
    return ItemProperty_Propertiy_IsValid(value);
  }
  static const Propertiy Propertiy_MIN =
    ItemProperty_Propertiy_Propertiy_MIN;
  static const Propertiy Propertiy_MAX =
    ItemProperty_Propertiy_Propertiy_MAX;
  static const int Propertiy_ARRAYSIZE =
    ItemProperty_Propertiy_Propertiy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Propertiy_descriptor() {
    return ItemProperty_Propertiy_descriptor();
  }
  static inline const ::std::string& Propertiy_Name(Propertiy value) {
    return ItemProperty_Propertiy_Name(value);
  }
  static inline bool Propertiy_Parse(const ::std::string& name,
      Propertiy* value) {
    return ItemProperty_Propertiy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .navit.protocol.map_info.MapPoint map_point = 2;
  bool has_map_point() const;
  void clear_map_point();
  static const int kMapPointFieldNumber = 2;
  private:
  const ::navit::protocol::map_info::MapPoint& _internal_map_point() const;
  public:
  const ::navit::protocol::map_info::MapPoint& map_point() const;
  ::navit::protocol::map_info::MapPoint* release_map_point();
  ::navit::protocol::map_info::MapPoint* mutable_map_point();
  void set_allocated_map_point(::navit::protocol::map_info::MapPoint* map_point);

  // .navit.protocol.map_info.MapLine map_line = 3;
  bool has_map_line() const;
  void clear_map_line();
  static const int kMapLineFieldNumber = 3;
  private:
  const ::navit::protocol::map_info::MapLine& _internal_map_line() const;
  public:
  const ::navit::protocol::map_info::MapLine& map_line() const;
  ::navit::protocol::map_info::MapLine* release_map_line();
  ::navit::protocol::map_info::MapLine* mutable_map_line();
  void set_allocated_map_line(::navit::protocol::map_info::MapLine* map_line);

  // .navit.protocol.map_info.MapArea map_polygon = 4;
  bool has_map_polygon() const;
  void clear_map_polygon();
  static const int kMapPolygonFieldNumber = 4;
  private:
  const ::navit::protocol::map_info::MapArea& _internal_map_polygon() const;
  public:
  const ::navit::protocol::map_info::MapArea& map_polygon() const;
  ::navit::protocol::map_info::MapArea* release_map_polygon();
  ::navit::protocol::map_info::MapArea* mutable_map_polygon();
  void set_allocated_map_polygon(::navit::protocol::map_info::MapArea* map_polygon);

  // .navit.protocol.map_info.ItemProperty.Propertiy item_property = 1;
  void clear_item_property();
  static const int kItemPropertyFieldNumber = 1;
  ::navit::protocol::map_info::ItemProperty_Propertiy item_property() const;
  void set_item_property(::navit::protocol::map_info::ItemProperty_Propertiy value);

  // @@protoc_insertion_point(class_scope:navit.protocol.map_info.ItemProperty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::navit::protocol::map_info::MapPoint* map_point_;
  ::navit::protocol::map_info::MapLine* map_line_;
  ::navit::protocol::map_info::MapArea* map_polygon_;
  int item_property_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_5fnavit_5fmap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Property

// string key = 1;
inline void Property::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Property::key() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Property.key)
  return key_.GetNoArena();
}
inline void Property::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Property.key)
}
#if LANG_CXX11
inline void Property::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.Property.key)
}
#endif
inline void Property::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.Property.key)
}
inline void Property::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.Property.key)
}
inline ::std::string* Property::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.Property.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Property::release_key() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.Property.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Property::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.Property.key)
}

// string type = 2;
inline void Property::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Property::type() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Property.type)
  return type_.GetNoArena();
}
inline void Property::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Property.type)
}
#if LANG_CXX11
inline void Property::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.Property.type)
}
#endif
inline void Property::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.Property.type)
}
inline void Property::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.Property.type)
}
inline ::std::string* Property::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.Property.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Property::release_type() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.Property.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Property::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.Property.type)
}

// string value = 3;
inline void Property::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Property::value() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Property.value)
  return value_.GetNoArena();
}
inline void Property::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Property.value)
}
#if LANG_CXX11
inline void Property::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.Property.value)
}
#endif
inline void Property::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.Property.value)
}
inline void Property::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.Property.value)
}
inline ::std::string* Property::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.Property.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Property::release_value() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.Property.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Property::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.Property.value)
}

// string desc = 4;
inline void Property::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Property::desc() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Property.desc)
  return desc_.GetNoArena();
}
inline void Property::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Property.desc)
}
#if LANG_CXX11
inline void Property::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.Property.desc)
}
#endif
inline void Property::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.Property.desc)
}
inline void Property::set_desc(const char* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.Property.desc)
}
inline ::std::string* Property::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.Property.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Property::release_desc() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.Property.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Property::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.Property.desc)
}

// -------------------------------------------------------------------

// Point

// double x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Point.x)
}

// double y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Point.y)
}

// double z = 3;
inline void Point::clear_z() {
  z_ = 0;
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Point.z)
}

// double rx = 4;
inline void Point::clear_rx() {
  rx_ = 0;
}
inline double Point::rx() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Point.rx)
  return rx_;
}
inline void Point::set_rx(double value) {
  
  rx_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Point.rx)
}

// double ry = 5;
inline void Point::clear_ry() {
  ry_ = 0;
}
inline double Point::ry() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Point.ry)
  return ry_;
}
inline void Point::set_ry(double value) {
  
  ry_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Point.ry)
}

// double rz = 6;
inline void Point::clear_rz() {
  rz_ = 0;
}
inline double Point::rz() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.Point.rz)
  return rz_;
}
inline void Point::set_rz(double value) {
  
  rz_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.Point.rz)
}

// -------------------------------------------------------------------

// MapBasicInfo

// int64 map_id = 1;
inline void MapBasicInfo::clear_map_id() {
  map_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MapBasicInfo::map_id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapBasicInfo.map_id)
  return map_id_;
}
inline void MapBasicInfo::set_map_id(::google::protobuf::int64 value) {
  
  map_id_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapBasicInfo.map_id)
}

// string map_name = 2;
inline void MapBasicInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapBasicInfo::map_name() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapBasicInfo.map_name)
  return map_name_.GetNoArena();
}
inline void MapBasicInfo::set_map_name(const ::std::string& value) {
  
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapBasicInfo.map_name)
}
#if LANG_CXX11
inline void MapBasicInfo::set_map_name(::std::string&& value) {
  
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapBasicInfo.map_name)
}
#endif
inline void MapBasicInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapBasicInfo.map_name)
}
inline void MapBasicInfo::set_map_name(const char* value, size_t size) {
  
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapBasicInfo.map_name)
}
inline ::std::string* MapBasicInfo::mutable_map_name() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapBasicInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapBasicInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapBasicInfo.map_name)
  
  return map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapBasicInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    
  } else {
    
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapBasicInfo.map_name)
}

// string map_type = 3;
inline void MapBasicInfo::clear_map_type() {
  map_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapBasicInfo::map_type() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapBasicInfo.map_type)
  return map_type_.GetNoArena();
}
inline void MapBasicInfo::set_map_type(const ::std::string& value) {
  
  map_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapBasicInfo.map_type)
}
#if LANG_CXX11
inline void MapBasicInfo::set_map_type(::std::string&& value) {
  
  map_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapBasicInfo.map_type)
}
#endif
inline void MapBasicInfo::set_map_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapBasicInfo.map_type)
}
inline void MapBasicInfo::set_map_type(const char* value, size_t size) {
  
  map_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapBasicInfo.map_type)
}
inline ::std::string* MapBasicInfo::mutable_map_type() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapBasicInfo.map_type)
  return map_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapBasicInfo::release_map_type() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapBasicInfo.map_type)
  
  return map_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapBasicInfo::set_allocated_map_type(::std::string* map_type) {
  if (map_type != NULL) {
    
  } else {
    
  }
  map_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_type);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapBasicInfo.map_type)
}

// .navit.protocol.map_info.Point min_pos = 4;
inline bool MapBasicInfo::has_min_pos() const {
  return this != internal_default_instance() && min_pos_ != NULL;
}
inline void MapBasicInfo::clear_min_pos() {
  if (GetArenaNoVirtual() == NULL && min_pos_ != NULL) {
    delete min_pos_;
  }
  min_pos_ = NULL;
}
inline const ::navit::protocol::map_info::Point& MapBasicInfo::_internal_min_pos() const {
  return *min_pos_;
}
inline const ::navit::protocol::map_info::Point& MapBasicInfo::min_pos() const {
  const ::navit::protocol::map_info::Point* p = min_pos_;
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapBasicInfo.min_pos)
  return p != NULL ? *p : *reinterpret_cast<const ::navit::protocol::map_info::Point*>(
      &::navit::protocol::map_info::_Point_default_instance_);
}
inline ::navit::protocol::map_info::Point* MapBasicInfo::release_min_pos() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapBasicInfo.min_pos)
  
  ::navit::protocol::map_info::Point* temp = min_pos_;
  min_pos_ = NULL;
  return temp;
}
inline ::navit::protocol::map_info::Point* MapBasicInfo::mutable_min_pos() {
  
  if (min_pos_ == NULL) {
    auto* p = CreateMaybeMessage<::navit::protocol::map_info::Point>(GetArenaNoVirtual());
    min_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapBasicInfo.min_pos)
  return min_pos_;
}
inline void MapBasicInfo::set_allocated_min_pos(::navit::protocol::map_info::Point* min_pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete min_pos_;
  }
  if (min_pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      min_pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_pos, submessage_arena);
    }
    
  } else {
    
  }
  min_pos_ = min_pos;
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapBasicInfo.min_pos)
}

// .navit.protocol.map_info.Point max_pos = 5;
inline bool MapBasicInfo::has_max_pos() const {
  return this != internal_default_instance() && max_pos_ != NULL;
}
inline void MapBasicInfo::clear_max_pos() {
  if (GetArenaNoVirtual() == NULL && max_pos_ != NULL) {
    delete max_pos_;
  }
  max_pos_ = NULL;
}
inline const ::navit::protocol::map_info::Point& MapBasicInfo::_internal_max_pos() const {
  return *max_pos_;
}
inline const ::navit::protocol::map_info::Point& MapBasicInfo::max_pos() const {
  const ::navit::protocol::map_info::Point* p = max_pos_;
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapBasicInfo.max_pos)
  return p != NULL ? *p : *reinterpret_cast<const ::navit::protocol::map_info::Point*>(
      &::navit::protocol::map_info::_Point_default_instance_);
}
inline ::navit::protocol::map_info::Point* MapBasicInfo::release_max_pos() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapBasicInfo.max_pos)
  
  ::navit::protocol::map_info::Point* temp = max_pos_;
  max_pos_ = NULL;
  return temp;
}
inline ::navit::protocol::map_info::Point* MapBasicInfo::mutable_max_pos() {
  
  if (max_pos_ == NULL) {
    auto* p = CreateMaybeMessage<::navit::protocol::map_info::Point>(GetArenaNoVirtual());
    max_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapBasicInfo.max_pos)
  return max_pos_;
}
inline void MapBasicInfo::set_allocated_max_pos(::navit::protocol::map_info::Point* max_pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete max_pos_;
  }
  if (max_pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      max_pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_pos, submessage_arena);
    }
    
  } else {
    
  }
  max_pos_ = max_pos;
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapBasicInfo.max_pos)
}

// double resolution = 6;
inline void MapBasicInfo::clear_resolution() {
  resolution_ = 0;
}
inline double MapBasicInfo::resolution() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapBasicInfo.resolution)
  return resolution_;
}
inline void MapBasicInfo::set_resolution(double value) {
  
  resolution_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapBasicInfo.resolution)
}

// string version = 7;
inline void MapBasicInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapBasicInfo::version() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapBasicInfo.version)
  return version_.GetNoArena();
}
inline void MapBasicInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapBasicInfo.version)
}
#if LANG_CXX11
inline void MapBasicInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapBasicInfo.version)
}
#endif
inline void MapBasicInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapBasicInfo.version)
}
inline void MapBasicInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapBasicInfo.version)
}
inline ::std::string* MapBasicInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapBasicInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapBasicInfo::release_version() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapBasicInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapBasicInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapBasicInfo.version)
}

// -------------------------------------------------------------------

// MapPoint

// int64 id = 1;
inline void MapPoint::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MapPoint::id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapPoint.id)
  return id_;
}
inline void MapPoint::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapPoint.id)
}

// string name = 2;
inline void MapPoint::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapPoint::name() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapPoint.name)
  return name_.GetNoArena();
}
inline void MapPoint::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapPoint.name)
}
#if LANG_CXX11
inline void MapPoint::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapPoint.name)
}
#endif
inline void MapPoint::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapPoint.name)
}
inline void MapPoint::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapPoint.name)
}
inline ::std::string* MapPoint::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapPoint.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapPoint::release_name() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapPoint.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapPoint::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapPoint.name)
}

// .navit.protocol.map_info.MapPoint.PointType type = 3;
inline void MapPoint::clear_type() {
  type_ = 0;
}
inline ::navit::protocol::map_info::MapPoint_PointType MapPoint::type() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapPoint.type)
  return static_cast< ::navit::protocol::map_info::MapPoint_PointType >(type_);
}
inline void MapPoint::set_type(::navit::protocol::map_info::MapPoint_PointType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapPoint.type)
}

// .navit.protocol.map_info.Point point = 4;
inline bool MapPoint::has_point() const {
  return this != internal_default_instance() && point_ != NULL;
}
inline void MapPoint::clear_point() {
  if (GetArenaNoVirtual() == NULL && point_ != NULL) {
    delete point_;
  }
  point_ = NULL;
}
inline const ::navit::protocol::map_info::Point& MapPoint::_internal_point() const {
  return *point_;
}
inline const ::navit::protocol::map_info::Point& MapPoint::point() const {
  const ::navit::protocol::map_info::Point* p = point_;
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapPoint.point)
  return p != NULL ? *p : *reinterpret_cast<const ::navit::protocol::map_info::Point*>(
      &::navit::protocol::map_info::_Point_default_instance_);
}
inline ::navit::protocol::map_info::Point* MapPoint::release_point() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapPoint.point)
  
  ::navit::protocol::map_info::Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline ::navit::protocol::map_info::Point* MapPoint::mutable_point() {
  
  if (point_ == NULL) {
    auto* p = CreateMaybeMessage<::navit::protocol::map_info::Point>(GetArenaNoVirtual());
    point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapPoint.point)
  return point_;
}
inline void MapPoint::set_allocated_point(::navit::protocol::map_info::Point* point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete point_;
  }
  if (point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapPoint.point)
}

// bool ignore_dir = 5;
inline void MapPoint::clear_ignore_dir() {
  ignore_dir_ = false;
}
inline bool MapPoint::ignore_dir() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapPoint.ignore_dir)
  return ignore_dir_;
}
inline void MapPoint::set_ignore_dir(bool value) {
  
  ignore_dir_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapPoint.ignore_dir)
}

// repeated .navit.protocol.map_info.Property property = 6;
inline int MapPoint::property_size() const {
  return property_.size();
}
inline void MapPoint::clear_property() {
  property_.Clear();
}
inline ::navit::protocol::map_info::Property* MapPoint::mutable_property(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapPoint.property)
  return property_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >*
MapPoint::mutable_property() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapPoint.property)
  return &property_;
}
inline const ::navit::protocol::map_info::Property& MapPoint::property(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapPoint.property)
  return property_.Get(index);
}
inline ::navit::protocol::map_info::Property* MapPoint::add_property() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapPoint.property)
  return property_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >&
MapPoint::property() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapPoint.property)
  return property_;
}

// -------------------------------------------------------------------

// MapLine

// int64 id = 1;
inline void MapLine::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MapLine::id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapLine.id)
  return id_;
}
inline void MapLine::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapLine.id)
}

// string name = 2;
inline void MapLine::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapLine::name() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapLine.name)
  return name_.GetNoArena();
}
inline void MapLine::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapLine.name)
}
#if LANG_CXX11
inline void MapLine::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapLine.name)
}
#endif
inline void MapLine::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapLine.name)
}
inline void MapLine::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapLine.name)
}
inline ::std::string* MapLine::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapLine.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapLine::release_name() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapLine.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapLine::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapLine.name)
}

// .navit.protocol.map_info.MapLine.LineType type = 3;
inline void MapLine::clear_type() {
  type_ = 0;
}
inline ::navit::protocol::map_info::MapLine_LineType MapLine::type() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapLine.type)
  return static_cast< ::navit::protocol::map_info::MapLine_LineType >(type_);
}
inline void MapLine::set_type(::navit::protocol::map_info::MapLine_LineType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapLine.type)
}

// int64 start_point_id = 4;
inline void MapLine::clear_start_point_id() {
  start_point_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MapLine::start_point_id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapLine.start_point_id)
  return start_point_id_;
}
inline void MapLine::set_start_point_id(::google::protobuf::int64 value) {
  
  start_point_id_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapLine.start_point_id)
}

// int64 end_point_id = 5;
inline void MapLine::clear_end_point_id() {
  end_point_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MapLine::end_point_id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapLine.end_point_id)
  return end_point_id_;
}
inline void MapLine::set_end_point_id(::google::protobuf::int64 value) {
  
  end_point_id_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapLine.end_point_id)
}

// repeated .navit.protocol.map_info.Point path = 6;
inline int MapLine::path_size() const {
  return path_.size();
}
inline void MapLine::clear_path() {
  path_.Clear();
}
inline ::navit::protocol::map_info::Point* MapLine::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapLine.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point >*
MapLine::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapLine.path)
  return &path_;
}
inline const ::navit::protocol::map_info::Point& MapLine::path(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapLine.path)
  return path_.Get(index);
}
inline ::navit::protocol::map_info::Point* MapLine::add_path() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapLine.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point >&
MapLine::path() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapLine.path)
  return path_;
}

// repeated .navit.protocol.map_info.Property property = 7;
inline int MapLine::property_size() const {
  return property_.size();
}
inline void MapLine::clear_property() {
  property_.Clear();
}
inline ::navit::protocol::map_info::Property* MapLine::mutable_property(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapLine.property)
  return property_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >*
MapLine::mutable_property() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapLine.property)
  return &property_;
}
inline const ::navit::protocol::map_info::Property& MapLine::property(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapLine.property)
  return property_.Get(index);
}
inline ::navit::protocol::map_info::Property* MapLine::add_property() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapLine.property)
  return property_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >&
MapLine::property() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapLine.property)
  return property_;
}

// -------------------------------------------------------------------

// MapArea

// int64 id = 1;
inline void MapArea::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MapArea::id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapArea.id)
  return id_;
}
inline void MapArea::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapArea.id)
}

// string name = 2;
inline void MapArea::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapArea::name() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapArea.name)
  return name_.GetNoArena();
}
inline void MapArea::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapArea.name)
}
#if LANG_CXX11
inline void MapArea::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapArea.name)
}
#endif
inline void MapArea::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapArea.name)
}
inline void MapArea::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapArea.name)
}
inline ::std::string* MapArea::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapArea.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapArea::release_name() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapArea.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapArea::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapArea.name)
}

// .navit.protocol.map_info.MapArea.AreaType type = 3;
inline void MapArea::clear_type() {
  type_ = 0;
}
inline ::navit::protocol::map_info::MapArea_AreaType MapArea::type() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapArea.type)
  return static_cast< ::navit::protocol::map_info::MapArea_AreaType >(type_);
}
inline void MapArea::set_type(::navit::protocol::map_info::MapArea_AreaType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapArea.type)
}

// int64 parent_id = 4;
inline void MapArea::clear_parent_id() {
  parent_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MapArea::parent_id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapArea.parent_id)
  return parent_id_;
}
inline void MapArea::set_parent_id(::google::protobuf::int64 value) {
  
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapArea.parent_id)
}

// repeated .navit.protocol.map_info.Point path = 5;
inline int MapArea::path_size() const {
  return path_.size();
}
inline void MapArea::clear_path() {
  path_.Clear();
}
inline ::navit::protocol::map_info::Point* MapArea::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapArea.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point >*
MapArea::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapArea.path)
  return &path_;
}
inline const ::navit::protocol::map_info::Point& MapArea::path(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapArea.path)
  return path_.Get(index);
}
inline ::navit::protocol::map_info::Point* MapArea::add_path() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapArea.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Point >&
MapArea::path() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapArea.path)
  return path_;
}

// repeated .navit.protocol.map_info.Property property = 6;
inline int MapArea::property_size() const {
  return property_.size();
}
inline void MapArea::clear_property() {
  property_.Clear();
}
inline ::navit::protocol::map_info::Property* MapArea::mutable_property(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapArea.property)
  return property_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >*
MapArea::mutable_property() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapArea.property)
  return &property_;
}
inline const ::navit::protocol::map_info::Property& MapArea::property(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapArea.property)
  return property_.Get(index);
}
inline ::navit::protocol::map_info::Property* MapArea::add_property() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapArea.property)
  return property_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::Property >&
MapArea::property() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapArea.property)
  return property_;
}

// -------------------------------------------------------------------

// MapInfo

// .navit.protocol.map_info.MapBasicInfo map_basic_info = 1;
inline bool MapInfo::has_map_basic_info() const {
  return this != internal_default_instance() && map_basic_info_ != NULL;
}
inline void MapInfo::clear_map_basic_info() {
  if (GetArenaNoVirtual() == NULL && map_basic_info_ != NULL) {
    delete map_basic_info_;
  }
  map_basic_info_ = NULL;
}
inline const ::navit::protocol::map_info::MapBasicInfo& MapInfo::_internal_map_basic_info() const {
  return *map_basic_info_;
}
inline const ::navit::protocol::map_info::MapBasicInfo& MapInfo::map_basic_info() const {
  const ::navit::protocol::map_info::MapBasicInfo* p = map_basic_info_;
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapInfo.map_basic_info)
  return p != NULL ? *p : *reinterpret_cast<const ::navit::protocol::map_info::MapBasicInfo*>(
      &::navit::protocol::map_info::_MapBasicInfo_default_instance_);
}
inline ::navit::protocol::map_info::MapBasicInfo* MapInfo::release_map_basic_info() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapInfo.map_basic_info)
  
  ::navit::protocol::map_info::MapBasicInfo* temp = map_basic_info_;
  map_basic_info_ = NULL;
  return temp;
}
inline ::navit::protocol::map_info::MapBasicInfo* MapInfo::mutable_map_basic_info() {
  
  if (map_basic_info_ == NULL) {
    auto* p = CreateMaybeMessage<::navit::protocol::map_info::MapBasicInfo>(GetArenaNoVirtual());
    map_basic_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapInfo.map_basic_info)
  return map_basic_info_;
}
inline void MapInfo::set_allocated_map_basic_info(::navit::protocol::map_info::MapBasicInfo* map_basic_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_basic_info_;
  }
  if (map_basic_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_basic_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_basic_info, submessage_arena);
    }
    
  } else {
    
  }
  map_basic_info_ = map_basic_info;
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapInfo.map_basic_info)
}

// repeated .navit.protocol.map_info.MapPoint map_points = 11;
inline int MapInfo::map_points_size() const {
  return map_points_.size();
}
inline void MapInfo::clear_map_points() {
  map_points_.Clear();
}
inline ::navit::protocol::map_info::MapPoint* MapInfo::mutable_map_points(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapInfo.map_points)
  return map_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapPoint >*
MapInfo::mutable_map_points() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapInfo.map_points)
  return &map_points_;
}
inline const ::navit::protocol::map_info::MapPoint& MapInfo::map_points(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapInfo.map_points)
  return map_points_.Get(index);
}
inline ::navit::protocol::map_info::MapPoint* MapInfo::add_map_points() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapInfo.map_points)
  return map_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapPoint >&
MapInfo::map_points() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapInfo.map_points)
  return map_points_;
}

// repeated .navit.protocol.map_info.MapLine map_lines = 12;
inline int MapInfo::map_lines_size() const {
  return map_lines_.size();
}
inline void MapInfo::clear_map_lines() {
  map_lines_.Clear();
}
inline ::navit::protocol::map_info::MapLine* MapInfo::mutable_map_lines(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapInfo.map_lines)
  return map_lines_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine >*
MapInfo::mutable_map_lines() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapInfo.map_lines)
  return &map_lines_;
}
inline const ::navit::protocol::map_info::MapLine& MapInfo::map_lines(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapInfo.map_lines)
  return map_lines_.Get(index);
}
inline ::navit::protocol::map_info::MapLine* MapInfo::add_map_lines() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapInfo.map_lines)
  return map_lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine >&
MapInfo::map_lines() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapInfo.map_lines)
  return map_lines_;
}

// repeated .navit.protocol.map_info.MapArea map_areas = 13;
inline int MapInfo::map_areas_size() const {
  return map_areas_.size();
}
inline void MapInfo::clear_map_areas() {
  map_areas_.Clear();
}
inline ::navit::protocol::map_info::MapArea* MapInfo::mutable_map_areas(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapInfo.map_areas)
  return map_areas_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapArea >*
MapInfo::mutable_map_areas() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapInfo.map_areas)
  return &map_areas_;
}
inline const ::navit::protocol::map_info::MapArea& MapInfo::map_areas(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapInfo.map_areas)
  return map_areas_.Get(index);
}
inline ::navit::protocol::map_info::MapArea* MapInfo::add_map_areas() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapInfo.map_areas)
  return map_areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapArea >&
MapInfo::map_areas() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapInfo.map_areas)
  return map_areas_;
}

// repeated .navit.protocol.map_info.MapLine map_forbidden_lines = 21;
inline int MapInfo::map_forbidden_lines_size() const {
  return map_forbidden_lines_.size();
}
inline void MapInfo::clear_map_forbidden_lines() {
  map_forbidden_lines_.Clear();
}
inline ::navit::protocol::map_info::MapLine* MapInfo::mutable_map_forbidden_lines(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapInfo.map_forbidden_lines)
  return map_forbidden_lines_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine >*
MapInfo::mutable_map_forbidden_lines() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.MapInfo.map_forbidden_lines)
  return &map_forbidden_lines_;
}
inline const ::navit::protocol::map_info::MapLine& MapInfo::map_forbidden_lines(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapInfo.map_forbidden_lines)
  return map_forbidden_lines_.Get(index);
}
inline ::navit::protocol::map_info::MapLine* MapInfo::add_map_forbidden_lines() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.MapInfo.map_forbidden_lines)
  return map_forbidden_lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapLine >&
MapInfo::map_forbidden_lines() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.MapInfo.map_forbidden_lines)
  return map_forbidden_lines_;
}

// -------------------------------------------------------------------

// MapConnectionInfo

// string from_map_id = 1;
inline void MapConnectionInfo::clear_from_map_id() {
  from_map_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapConnectionInfo::from_map_id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapConnectionInfo.from_map_id)
  return from_map_id_.GetNoArena();
}
inline void MapConnectionInfo::set_from_map_id(const ::std::string& value) {
  
  from_map_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapConnectionInfo.from_map_id)
}
#if LANG_CXX11
inline void MapConnectionInfo::set_from_map_id(::std::string&& value) {
  
  from_map_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapConnectionInfo.from_map_id)
}
#endif
inline void MapConnectionInfo::set_from_map_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_map_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapConnectionInfo.from_map_id)
}
inline void MapConnectionInfo::set_from_map_id(const char* value, size_t size) {
  
  from_map_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapConnectionInfo.from_map_id)
}
inline ::std::string* MapConnectionInfo::mutable_from_map_id() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapConnectionInfo.from_map_id)
  return from_map_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapConnectionInfo::release_from_map_id() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapConnectionInfo.from_map_id)
  
  return from_map_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapConnectionInfo::set_allocated_from_map_id(::std::string* from_map_id) {
  if (from_map_id != NULL) {
    
  } else {
    
  }
  from_map_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_map_id);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapConnectionInfo.from_map_id)
}

// string from_map_point_id = 2;
inline void MapConnectionInfo::clear_from_map_point_id() {
  from_map_point_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapConnectionInfo::from_map_point_id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapConnectionInfo.from_map_point_id)
  return from_map_point_id_.GetNoArena();
}
inline void MapConnectionInfo::set_from_map_point_id(const ::std::string& value) {
  
  from_map_point_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapConnectionInfo.from_map_point_id)
}
#if LANG_CXX11
inline void MapConnectionInfo::set_from_map_point_id(::std::string&& value) {
  
  from_map_point_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapConnectionInfo.from_map_point_id)
}
#endif
inline void MapConnectionInfo::set_from_map_point_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_map_point_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapConnectionInfo.from_map_point_id)
}
inline void MapConnectionInfo::set_from_map_point_id(const char* value, size_t size) {
  
  from_map_point_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapConnectionInfo.from_map_point_id)
}
inline ::std::string* MapConnectionInfo::mutable_from_map_point_id() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapConnectionInfo.from_map_point_id)
  return from_map_point_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapConnectionInfo::release_from_map_point_id() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapConnectionInfo.from_map_point_id)
  
  return from_map_point_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapConnectionInfo::set_allocated_from_map_point_id(::std::string* from_map_point_id) {
  if (from_map_point_id != NULL) {
    
  } else {
    
  }
  from_map_point_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_map_point_id);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapConnectionInfo.from_map_point_id)
}

// string to_map_id = 3;
inline void MapConnectionInfo::clear_to_map_id() {
  to_map_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapConnectionInfo::to_map_id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapConnectionInfo.to_map_id)
  return to_map_id_.GetNoArena();
}
inline void MapConnectionInfo::set_to_map_id(const ::std::string& value) {
  
  to_map_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapConnectionInfo.to_map_id)
}
#if LANG_CXX11
inline void MapConnectionInfo::set_to_map_id(::std::string&& value) {
  
  to_map_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapConnectionInfo.to_map_id)
}
#endif
inline void MapConnectionInfo::set_to_map_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_map_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapConnectionInfo.to_map_id)
}
inline void MapConnectionInfo::set_to_map_id(const char* value, size_t size) {
  
  to_map_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapConnectionInfo.to_map_id)
}
inline ::std::string* MapConnectionInfo::mutable_to_map_id() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapConnectionInfo.to_map_id)
  return to_map_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapConnectionInfo::release_to_map_id() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapConnectionInfo.to_map_id)
  
  return to_map_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapConnectionInfo::set_allocated_to_map_id(::std::string* to_map_id) {
  if (to_map_id != NULL) {
    
  } else {
    
  }
  to_map_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_map_id);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapConnectionInfo.to_map_id)
}

// string to_map_point_id = 4;
inline void MapConnectionInfo::clear_to_map_point_id() {
  to_map_point_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapConnectionInfo::to_map_point_id() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapConnectionInfo.to_map_point_id)
  return to_map_point_id_.GetNoArena();
}
inline void MapConnectionInfo::set_to_map_point_id(const ::std::string& value) {
  
  to_map_point_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapConnectionInfo.to_map_point_id)
}
#if LANG_CXX11
inline void MapConnectionInfo::set_to_map_point_id(::std::string&& value) {
  
  to_map_point_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navit.protocol.map_info.MapConnectionInfo.to_map_point_id)
}
#endif
inline void MapConnectionInfo::set_to_map_point_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_map_point_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navit.protocol.map_info.MapConnectionInfo.to_map_point_id)
}
inline void MapConnectionInfo::set_to_map_point_id(const char* value, size_t size) {
  
  to_map_point_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navit.protocol.map_info.MapConnectionInfo.to_map_point_id)
}
inline ::std::string* MapConnectionInfo::mutable_to_map_point_id() {
  
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.MapConnectionInfo.to_map_point_id)
  return to_map_point_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapConnectionInfo::release_to_map_point_id() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.MapConnectionInfo.to_map_point_id)
  
  return to_map_point_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapConnectionInfo::set_allocated_to_map_point_id(::std::string* to_map_point_id) {
  if (to_map_point_id != NULL) {
    
  } else {
    
  }
  to_map_point_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_map_point_id);
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.MapConnectionInfo.to_map_point_id)
}

// double cost = 5;
inline void MapConnectionInfo::clear_cost() {
  cost_ = 0;
}
inline double MapConnectionInfo::cost() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.MapConnectionInfo.cost)
  return cost_;
}
inline void MapConnectionInfo::set_cost(double value) {
  
  cost_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.MapConnectionInfo.cost)
}

// -------------------------------------------------------------------

// TotalMapInfo

// repeated .navit.protocol.map_info.MapInfo map_infos = 1;
inline int TotalMapInfo::map_infos_size() const {
  return map_infos_.size();
}
inline void TotalMapInfo::clear_map_infos() {
  map_infos_.Clear();
}
inline ::navit::protocol::map_info::MapInfo* TotalMapInfo::mutable_map_infos(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.TotalMapInfo.map_infos)
  return map_infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapInfo >*
TotalMapInfo::mutable_map_infos() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.TotalMapInfo.map_infos)
  return &map_infos_;
}
inline const ::navit::protocol::map_info::MapInfo& TotalMapInfo::map_infos(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.TotalMapInfo.map_infos)
  return map_infos_.Get(index);
}
inline ::navit::protocol::map_info::MapInfo* TotalMapInfo::add_map_infos() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.TotalMapInfo.map_infos)
  return map_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapInfo >&
TotalMapInfo::map_infos() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.TotalMapInfo.map_infos)
  return map_infos_;
}

// repeated .navit.protocol.map_info.MapConnectionInfo map_connection_infos = 2;
inline int TotalMapInfo::map_connection_infos_size() const {
  return map_connection_infos_.size();
}
inline void TotalMapInfo::clear_map_connection_infos() {
  map_connection_infos_.Clear();
}
inline ::navit::protocol::map_info::MapConnectionInfo* TotalMapInfo::mutable_map_connection_infos(int index) {
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.TotalMapInfo.map_connection_infos)
  return map_connection_infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapConnectionInfo >*
TotalMapInfo::mutable_map_connection_infos() {
  // @@protoc_insertion_point(field_mutable_list:navit.protocol.map_info.TotalMapInfo.map_connection_infos)
  return &map_connection_infos_;
}
inline const ::navit::protocol::map_info::MapConnectionInfo& TotalMapInfo::map_connection_infos(int index) const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.TotalMapInfo.map_connection_infos)
  return map_connection_infos_.Get(index);
}
inline ::navit::protocol::map_info::MapConnectionInfo* TotalMapInfo::add_map_connection_infos() {
  // @@protoc_insertion_point(field_add:navit.protocol.map_info.TotalMapInfo.map_connection_infos)
  return map_connection_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::navit::protocol::map_info::MapConnectionInfo >&
TotalMapInfo::map_connection_infos() const {
  // @@protoc_insertion_point(field_list:navit.protocol.map_info.TotalMapInfo.map_connection_infos)
  return map_connection_infos_;
}

// -------------------------------------------------------------------

// ItemProperty

// .navit.protocol.map_info.ItemProperty.Propertiy item_property = 1;
inline void ItemProperty::clear_item_property() {
  item_property_ = 0;
}
inline ::navit::protocol::map_info::ItemProperty_Propertiy ItemProperty::item_property() const {
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.ItemProperty.item_property)
  return static_cast< ::navit::protocol::map_info::ItemProperty_Propertiy >(item_property_);
}
inline void ItemProperty::set_item_property(::navit::protocol::map_info::ItemProperty_Propertiy value) {
  
  item_property_ = value;
  // @@protoc_insertion_point(field_set:navit.protocol.map_info.ItemProperty.item_property)
}

// .navit.protocol.map_info.MapPoint map_point = 2;
inline bool ItemProperty::has_map_point() const {
  return this != internal_default_instance() && map_point_ != NULL;
}
inline void ItemProperty::clear_map_point() {
  if (GetArenaNoVirtual() == NULL && map_point_ != NULL) {
    delete map_point_;
  }
  map_point_ = NULL;
}
inline const ::navit::protocol::map_info::MapPoint& ItemProperty::_internal_map_point() const {
  return *map_point_;
}
inline const ::navit::protocol::map_info::MapPoint& ItemProperty::map_point() const {
  const ::navit::protocol::map_info::MapPoint* p = map_point_;
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.ItemProperty.map_point)
  return p != NULL ? *p : *reinterpret_cast<const ::navit::protocol::map_info::MapPoint*>(
      &::navit::protocol::map_info::_MapPoint_default_instance_);
}
inline ::navit::protocol::map_info::MapPoint* ItemProperty::release_map_point() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.ItemProperty.map_point)
  
  ::navit::protocol::map_info::MapPoint* temp = map_point_;
  map_point_ = NULL;
  return temp;
}
inline ::navit::protocol::map_info::MapPoint* ItemProperty::mutable_map_point() {
  
  if (map_point_ == NULL) {
    auto* p = CreateMaybeMessage<::navit::protocol::map_info::MapPoint>(GetArenaNoVirtual());
    map_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.ItemProperty.map_point)
  return map_point_;
}
inline void ItemProperty::set_allocated_map_point(::navit::protocol::map_info::MapPoint* map_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_point_;
  }
  if (map_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_point, submessage_arena);
    }
    
  } else {
    
  }
  map_point_ = map_point;
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.ItemProperty.map_point)
}

// .navit.protocol.map_info.MapLine map_line = 3;
inline bool ItemProperty::has_map_line() const {
  return this != internal_default_instance() && map_line_ != NULL;
}
inline void ItemProperty::clear_map_line() {
  if (GetArenaNoVirtual() == NULL && map_line_ != NULL) {
    delete map_line_;
  }
  map_line_ = NULL;
}
inline const ::navit::protocol::map_info::MapLine& ItemProperty::_internal_map_line() const {
  return *map_line_;
}
inline const ::navit::protocol::map_info::MapLine& ItemProperty::map_line() const {
  const ::navit::protocol::map_info::MapLine* p = map_line_;
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.ItemProperty.map_line)
  return p != NULL ? *p : *reinterpret_cast<const ::navit::protocol::map_info::MapLine*>(
      &::navit::protocol::map_info::_MapLine_default_instance_);
}
inline ::navit::protocol::map_info::MapLine* ItemProperty::release_map_line() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.ItemProperty.map_line)
  
  ::navit::protocol::map_info::MapLine* temp = map_line_;
  map_line_ = NULL;
  return temp;
}
inline ::navit::protocol::map_info::MapLine* ItemProperty::mutable_map_line() {
  
  if (map_line_ == NULL) {
    auto* p = CreateMaybeMessage<::navit::protocol::map_info::MapLine>(GetArenaNoVirtual());
    map_line_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.ItemProperty.map_line)
  return map_line_;
}
inline void ItemProperty::set_allocated_map_line(::navit::protocol::map_info::MapLine* map_line) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_line_;
  }
  if (map_line) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_line = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_line, submessage_arena);
    }
    
  } else {
    
  }
  map_line_ = map_line;
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.ItemProperty.map_line)
}

// .navit.protocol.map_info.MapArea map_polygon = 4;
inline bool ItemProperty::has_map_polygon() const {
  return this != internal_default_instance() && map_polygon_ != NULL;
}
inline void ItemProperty::clear_map_polygon() {
  if (GetArenaNoVirtual() == NULL && map_polygon_ != NULL) {
    delete map_polygon_;
  }
  map_polygon_ = NULL;
}
inline const ::navit::protocol::map_info::MapArea& ItemProperty::_internal_map_polygon() const {
  return *map_polygon_;
}
inline const ::navit::protocol::map_info::MapArea& ItemProperty::map_polygon() const {
  const ::navit::protocol::map_info::MapArea* p = map_polygon_;
  // @@protoc_insertion_point(field_get:navit.protocol.map_info.ItemProperty.map_polygon)
  return p != NULL ? *p : *reinterpret_cast<const ::navit::protocol::map_info::MapArea*>(
      &::navit::protocol::map_info::_MapArea_default_instance_);
}
inline ::navit::protocol::map_info::MapArea* ItemProperty::release_map_polygon() {
  // @@protoc_insertion_point(field_release:navit.protocol.map_info.ItemProperty.map_polygon)
  
  ::navit::protocol::map_info::MapArea* temp = map_polygon_;
  map_polygon_ = NULL;
  return temp;
}
inline ::navit::protocol::map_info::MapArea* ItemProperty::mutable_map_polygon() {
  
  if (map_polygon_ == NULL) {
    auto* p = CreateMaybeMessage<::navit::protocol::map_info::MapArea>(GetArenaNoVirtual());
    map_polygon_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navit.protocol.map_info.ItemProperty.map_polygon)
  return map_polygon_;
}
inline void ItemProperty::set_allocated_map_polygon(::navit::protocol::map_info::MapArea* map_polygon) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_polygon_;
  }
  if (map_polygon) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_polygon = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_polygon, submessage_arena);
    }
    
  } else {
    
  }
  map_polygon_ = map_polygon;
  // @@protoc_insertion_point(field_set_allocated:navit.protocol.map_info.ItemProperty.map_polygon)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace map_info
}  // namespace protocol
}  // namespace navit

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::navit::protocol::map_info::MapPoint_PointType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navit::protocol::map_info::MapPoint_PointType>() {
  return ::navit::protocol::map_info::MapPoint_PointType_descriptor();
}
template <> struct is_proto_enum< ::navit::protocol::map_info::MapLine_LineType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navit::protocol::map_info::MapLine_LineType>() {
  return ::navit::protocol::map_info::MapLine_LineType_descriptor();
}
template <> struct is_proto_enum< ::navit::protocol::map_info::MapArea_AreaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navit::protocol::map_info::MapArea_AreaType>() {
  return ::navit::protocol::map_info::MapArea_AreaType_descriptor();
}
template <> struct is_proto_enum< ::navit::protocol::map_info::ItemProperty_Propertiy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navit::protocol::map_info::ItemProperty_Propertiy>() {
  return ::navit::protocol::map_info::ItemProperty_Propertiy_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_message_5fnavit_5fmap_2eproto
