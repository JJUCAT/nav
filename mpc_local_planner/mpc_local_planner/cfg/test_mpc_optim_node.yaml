## Robot settings
robot:
  type: "unicycle"
  unicycle: # 独轮车模型，差速轮模型
    max_vel_x: 0.4
    max_vel_x_backwards: 0.2
    max_vel_theta: 0.3
    acc_lim_x: 0.0 # deactive bounds with zero
    dec_lim_x: 0.0 # deactive bounds with zero
    acc_lim_theta: 0.0 # deactivate bounds with zero
  simple_car: # 类车模型
    wheelbase: 0.4
    front_wheel_driving: False # 是否前驱，后驱车爬坡能力差
    max_vel_x: 0.4
    max_vel_x_backwards: 0.2
    max_steering_angle: 1.4
    acc_lim_x: 0.0 # deactive bounds with zero
    dec_lim_x: 0.0 # deactive bounds with zero
    max_steering_rate: 0.5 # deactive bounds with zero
  kinematic_bicycle_vel_input: # 单车模型
    length_rear: 1.0
    length_front: 1.0
    max_vel_x: 0.4
    max_vel_x_backwards: 0.2
    max_steering_angle: 1.4
    acc_lim_x: 0.0 # deactive bounds with zero
    dec_lim_x: 0.0 # deactive bounds with zero
    max_steering_rate: 0.5 # deactive bounds with zero

## Footprint model for collision avoidance
footprint_model:
  type: "point"

collision_avoidance:
  min_obstacle_dist: 0.5 # Note, this parameter must be chosen w.r.t. the footprint_model
  enable_dynamic_obstacles: False
  force_inclusion_dist: 0.5
  cutoff_dist: 2.5 
  collision_check_no_poses: 5

## Planning grid 
grid:
  type: "fd_grid" # 有限离散时间网格，默认是固定网格
  grid_size_ref: 20 # 网格数量大小
  dt_ref: 0.3 # 网格分辨率大小
  # xf 是最后一个时间网格，这里设置最后网格的 x y theta 是否是硬约束
  xf_fixed: [True, True, True] # E.g., set last one to False in order to unfix the final orientation
  warm_start: True
  collocation_method: "forward_differences"
  cost_integration_method: "left_sum" # 时间网格代价是累加的
  variable_grid: # 动态时间网格
    enable: True  # 动态网格分辨率大小
    min_dt: 0.0;
    max_dt: 10.0;
    grid_adaptation:
      enable: True # 动态网格数量大小
      dt_hyst_ratio: 0.1
      min_grid_size: 2
      max_grid_size: 50


## Planning options
planning:
  objective: # 代价配置
    # @ minimum_time 时间最小 @ quadratic_form ? @ minimum_time_via_points ? @ 
    type: "minimum_time" # minimum_time requires grid/variable_grid/enable=True and grid/xf_fixed set properly
    quadratic_form:
      state_weights: [2.0, 2.0, 2.0]
      control_weights: [1.0, 1.0]
      integral_form: False
      hybrid_cost_minimum_time: False
    minimum_time_via_points:
      position_weight: 8.0
      orientation_weight: 0.0
      via_points_ordered: False
  terminal_cost: # 终点代价配置
    # @none ? @ quadratic ?
    type: "quadratic" # can be "none"
    quadratic:
      final_state_weights: [2.0, 2.0, 2.0]
  terminal_constraint: # 终点约束
    # @ none @ l2_ball ?
    type: "none" # can be "none"
    l2_ball:
      weight_matrix: [1.0, 1.0, 1.0]
      radius: 5


## Controller options
controller:
  outer_ocp_iterations: 1
  xy_goal_tolerance: 0.2
  yaw_goal_tolerance: 0.1
  force_reinit_new_goal_dist: 1.0
  force_reinit_new_goal_angular: 1.57
  force_reinit_num_steps: 0
  global_plan_overwrite_orientation: True
  global_plan_viapoint_sep: -1
  allow_init_with_backward_motion: True
  publish_ocp_results: True
  print_cpu_time: False
  
## Solver settings
solver:
  type: "ipopt"
  ipopt: # 求解器 ipopt 内点法
    iterations: 100 # 优化迭代次数，次数越多效果越好，约费时间
    max_cpu_time: -1.0
    ipopt_numeric_options:
      tol: 1e-4 # tolerance
    ipopt_string_options:
      linear_solver: "mumps" # 直接线性求解，对于稀疏矩阵会浪费时间
      hessian_approximation: "limited-memory" # exact or limited-memory # 内存限制，对于直接线性求解，会浪费内存在稀疏矩阵上
    ipopt_integer_options:
      print_level: 2
  lsq_lm: # 求解器 Levenberg-Marquardt (LM or DLS) 阻尼最小二乘法
    iterations: 10
    weight_init_eq: 2
    weight_init_ineq: 2
    weight_init_bounds: 2
    weight_adapt_factor_eq: 1.5
    weight_adapt_factor_ineq: 1.5
    weight_adapt_factor_bounds: 1.5
    weight_adapt_max_eq: 500
    weight_adapt_max_ineq: 500
    weight_adapt_max_bounds: 500


